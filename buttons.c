/*----------------------------------------------------------------------------
 *      
 *----------------------------------------------------------------------------
 *      Name:    BUTTONS.H
 *      Purpose: Microprocessors Laboratory
 *----------------------------------------------------------------------------
 *      
 *      Author: Pawel Russek AGH University of Science and Technology
 *---------------------------------------------------------------------------*/

#include "MKL46Z4.h"                    /* Device header */
#include "buttons.h"


#define SW1_PIN 3												/* SW1 switch is on port C - pin 3 */
#define SW3_PIN 12											/* SW 3 in on port C pin 12 */

/*Number of IRQ generated by PORTC_PORTD interrupt*/
#define PORTC_D_IRQ_NBR (IRQn_Type) 31					
uint8_t volatile function=0 ;
float t,p,l;
	int16_t h;
/*----------------------------------------------------------------------------
	Function reads SW 1 SW 3 state
*----------------------------------------------------------------------------*/
int32_t button1Read(){
	return FPTC->PDIR & (1UL<<SW1_PIN);						/* Get port data input register (PDIR) */
}	

int32_t button3Read(){
	return FPTC->PDIR & (1UL<<SW3_PIN);						/* Get port data input register (PDIR) */
}	

uint8_t current_function (void)
	{
		return function;
	}


/*----------------------------------------------------------------------------
	Interrupt service routine
	Button will cause PORTC_PORTD interrupt 
 *----------------------------------------------------------------------------*/
void PORTC_PORTD_IRQHandler(void)
	{
//	if((button1Read()==0)
//	{
//	button1Service();
//	PORTC->PCR[SW1_PIN] |= PORT_PCR_ISF_MASK;
//	}

		if(button3Read()==0)
		{
		button3Service();
		PORTC->PCR[SW3_PIN] |= PORT_PCR_ISF_MASK;	
		}
  }

/*----------------------------------------------------------------------------
	Function initializes port C pin for switch 1 (SW1) handling
	and enables PORT_C_D interrupts
 *----------------------------------------------------------------------------*/
void buttonsInitialize(void){
	
	SIM->SCGC5 |=  SIM_SCGC5_PORTC_MASK; 					/* Enable clock for port C */
	PORTC->PCR[SW1_PIN] |= PORT_PCR_MUX(1);      	/* Pin PTC3 is GPIO */
	PORTC->PCR[SW3_PIN] |= PORT_PCR_MUX(1); 
	
	/* Port control register for bit 3 of port C configuration. Activate pull up and interrupt */
  PORTC->PCR[SW1_PIN] |=  PORT_PCR_PE_MASK |		
	  											PORT_PCR_PS_MASK;		
	PORTC->PCR[SW1_PIN] |= 	PORT_PCR_IRQC(0xA);
		
	PORTC->PCR[SW3_PIN] |=  PORT_PCR_PE_MASK |		
	  											PORT_PCR_PS_MASK;		
	PORTC->PCR[SW3_PIN] |= 	PORT_PCR_IRQC(0xA);
	
	 //ARM's Nested Vector Interrupt Controller configuration
	
	NVIC_ClearPendingIRQ(PORTC_D_IRQ_NBR);				/* Clear NVIC any pending interrupts on PORTC_D */
	NVIC_EnableIRQ(PORTC_D_IRQ_NBR);							/* Enable NVIC interrupts source for PORTC_D module */
	NVIC_SetPriority (PORTC_D_IRQ_NBR, 1);		/* Set PORTC_D interrupt priority level  */ 

}


/*----------------------------------------------------------------------------
	Function services PORT_C_D interrupt
*----------------------------------------------------------------------------*/
void button1Service(void){
															
}

void button3Service(void)
	{	
		//sensorsDisplay(current_function());
		switch(function)
		{
			case 0 :
			{
				ledsOff();
				function=1;
				t=tempRead();
				//slcdDisplay(tempRead(),10);
			 break;
			}
			case 1 :
			{
				ledredOn();
				function=2;
				l=lightRead();
				//slcdDisplay(lightRead(),10);
			 break;
			}
			case 2 :
			{
				ledsOff();
				ledgreenOn();
				function=3;
				p=pressRead();
				//slcdDisplay(pressRead(),10);	
			 break;
			}
			case 3 :
			{
				ledredOn();
				function=0;
				h=humidRead();
				//slcdDisplay(humidRead(),10);	
			 break;
			}
		}
	}
